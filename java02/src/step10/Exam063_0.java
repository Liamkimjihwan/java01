/* 스태틱 변수와 인스턴스 변수 - 생성
*/
package step10;

import java.util.Scanner;

 public class Exam063_0 {
  static class Mytype { //Exam063_0과 Mytype 클래스 파일이 따로 생성됨.
    static int a; //스태틱 변수
    int b; // 인스턴스 변수
  }


   public static void main(String[] args) {
  Mytype.a = 100; // 스태틱 변수는 클래스 이름(주소)으로 접근한다.
  System.out.println(Mytype.a);


 // Mytype.b = 100; // non_static 변수 = 인스턴스 변수는 인스턴스 주소가 있어야한다.
                 // 지금처럼 클래스 변수처럼 쓸수 없다. 컴파일 오류


 // 인스턴스 변수 사용법
 // => 인스턴스를 먼저 만든다.
 Mytype obj = new Mytype();
 // => 인스턴스 주소를 통해 인스턴스 변수에 접근한다.
obj.b = 200;
// obj에 있는 b를 찾아서 100을 저장하라.
// 또 다른 인스턴스
Mytype obj2 = new Mytype();
obj2.b = 300;


System.out.println(obj.b);
System.out.println(obj2.b);



}
}





/*
# 스태틱 변수는 클래스가 메서드 에리어에 로딩 될 때 자동으로 준비되는 변수이다.
- JVM이 종료될 때까지 유지된다.
- 클래스는 한 번만 메모리에 로딩(HDD-->RAM)된다.
- 명령어는 프로그램을 실행할 때 명령어는 여러 번 중복해서 메모리에 복사될 필요가 없다.
- 명령어는 바뀌는 것이 아니다.
- 스태틱 변수도 한 번만 생성된다.(메모리에 변수 그릇이 만들어진다.)
 스태틱 변수는 클래스 주소(클래스 이름)를 통해서 접근할 수 있다.
 스태틱 변수는 클래스 변수라고도 한다.

#인스턴스 변수 = non-static
- 인스턴스를 생성할 때 Heap 영역에 준비되는 변수
- 인스턴스 변수에 접근하려면 인스턴스 주소가 있어야함.
- 가비지(그 인스턴스 주소를 알고있는 변수가 없어야함)가 되고 난 후
  가비지 컬렉터(CPU가 한가할 때, 만들어진 인스턴스 변수가 쓸모가 없어질 때 만들어짐)가
  메모리를 해제할 때 인스턴스 변수는 제거.
 인스턴스는 new 명령을 수행해야만 생성된다.
 인스턴스 변수는 스태틱 변수와 달리 여러개를 만들 수 있다.
 => 인스턴스를 만들 때마다 인스턴스 변수가 생성된다.


 # 인스턴스 생성과 메서드
 - 인스턴스를 생성한다는 뜻은 Heap 영역에 인스턴스 변수를 준비한다는 뜻.
 인스턴스를 생성할 때 메서드를 준비하는 것은 아니다.
 인스턴스를 만들 때 메서드도 같이 Heap에 만들어지는게 아니다.
 인스턴스를 만든다는 것은 인스턴스 변수를 만든다는 것.
 메서드는 스태틱 메서드가 되었든, 인스턴스 메서드가 되었든
 클래스가 로딩될 때 메서드 에리어에 올라간다.
 클래스가 메서드를 담고있는 그릇이기에
 클래스가 로딩된다는 건 그 그릇 안에 들어있는 메서드들도 함께 로딩된다는 뜻.
 스태틱 메서드가 되었든, 인스턴스 메서드가 되었든 상관없이 클래스가 로딩될 때
 메서드 에리어 영역에 로딩된다.




- JVM이 클래스를 로딩(복사)
-컴파일하면 소스당 클래스가 만들어지는게 아니라
 클래스 당 하나의 클래스 파일이 만들어짐
 Exam063_0과 Mytype(inner class) 클래스 파일이 따로 생성됨.
 Exam063_0.class
 Exam063_0.class$Mytype.class



*/
