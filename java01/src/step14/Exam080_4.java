/* 주제 : 예외 처리 - Error 예외에 대해 자세히
  = > 개발자가 애플리케이션에서 던지는 것이 아니다.
  => JVM에서 실행 중에 예외 상황이 발생했을 때 주로 던진다.
  => 예외를 던진다고해서 메서드에 선언해도 되지만 선언할 필요는 없다.

 */
package step14;
import java.util.Scanner;

 public class Exam080_4  {

    static int m1() {
      throw new Error("예외 발생!"); // 패키지가 없으니 java.lang 임
      }

    // 예외를 던진다고 선언해도 된다. 선택사항이다.
     static int m2() throws Error {
        throw new Error("예외 발생!"); // 패키지가 없으니 java.lang 임
      }
    
   public static void main(String[] args)  {
     // 왜 멈췄는가..
     // 1) Error 예외를 처리하지 않으면 메서드의 실행을 즉시 멈추고
     //    상위 호출자에게 자동으로 예외 객체를 전달한다.
     //    자동 전달된다
     //  => main() 메서드의 상위 호출자 = > JVM이다.
     //  => JVM은 예외를 받으면 그냥 예외 정보를 꺼내 출력한다.
     // 2) 상위 호출자에게 예외를 전달하기 싫다면, try ~ catch ~ 문법을 사용하여
     //    예외를 처리하라.
     //m1();

   /* 
    try {
     m1();
       } catch (Error e) {
         System.out.println("오호라..예외발생"); 
       }
*/

// 3) Error 객체를 던지는 경우, 메서드 선언부에 예외를 던진다고 되어 있거나
//    되어 있지 않거나 동일하게 다룬다.
// 즉 m1() m2() 는 똑같다.
// 그럼에도 불구하고 개발자가 m2()를 정의할 때, 메서드 선언부에 
// 어떤 예외를 던지는지 선언했다면 그것은 다른 개발자에게 자신이 만든
// 메서드가 어떤 예외를 던질 수 있는지 알려주기 위함이다.
    m2();
      }
    }



/*
#
nextInt()
=> 사용자가 입력한 문자열에서 공백 또는 줄바꿈 코드를 만나면 그 문자열을 끊어서
숫자로 바꾼 다음 리턴한다.
단, 한 개 문자열만 끊어서 숫자로 바꾼다.








*/
